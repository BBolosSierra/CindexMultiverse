---
title: "Sensitivity analysis for METABRIC, increasing the number of ties in times and predictions"
output: html_document
date: "<small>`r Sys.Date()`</small>"
---

# Introduction 
Here, we perform a sensitivity analysis to assess the effect of ties on different
C-index implementations. This is Based on the METABRIC dataset, for which the 
number of ties (in predictions and in times) was artificially increased via 
rounding. 

In this section, we first load the required libraries:


```{r Load libraries include=FALSE}
# Survival metrics
library(reticulate)
library(arrow)
library(caret)
library(riskRegression)
library(prodlim)
library(pec)
library(survival)
library(rhdf5)
library(randomForestSRC)
library(Hmisc)
library(dplyr)
# Plotting
library(gridExtra)
# Parallelization
library(doFuture)
library(future)
library(progressr)
library(foreach)
library(MASS)
library(flexsurv)
library(furrr)
library(tidyr)
library(kableExtra)
```


```{r setup, include=FALSE}
#Sys.unsetenv("RETICULATE_PYTHON")
Sys.setenv(OMP_NUM_THREADS = "1")       # Limits OpenMP to 1 thread
Sys.setenv(NUMBA_NUM_THREADS = "1")     # Limits Numba to 1 thread
Sys.setenv(MKL_NUM_THREADS = "1")       # Limits Intel MKL to 1 thread
Sys.setenv(KMP_WARNINGS = "0")          # Disables OpenMP warnings
Sys.setenv(OPENBLAS_NUM_THREADS = "1")  # Limits OpenBLAS to 1 thread

# #Sys.setenv(NUMBA_DISABLE_JIT = "0")  
# library(reticulate)

#use_condaenv("/opt/homebrew/Caskroom/miniforge/base/envs/py-rstudio", required=TRUE)
#use_virtualenv("~/.virtualenvs/venv-DeSurv_python_R")
#use_python("/opt/homebrew/Caskroom/miniforge/base/envs/venv-DeSurv3/bin/python3.9")
#py_config()
```


Subsequently, we load the pre-processed METABRIC dataset. 

```{r load data}
# Load data downloaded from the cBioPortal 
mb <- read.table("./Datasets/metabric_preprocess_multiverse.csv", 
                 sep = "," , header = TRUE)

# Keep the id as index
rownames(mb) <- mb$PATIENT_ID

# Remove the id column
mb <- mb[,2:12]

# Mapping
var_map <- c(
  "MKI67" = "X1",
  "EGFR" = "X2",
  "ERBB2" = "X3",
  "PGR" = "X4",
  "HORMONE_THERAPY" = "X5",
  "RADIO_THERAPY" = "X6",
  "CHEMOTHERAPY" = "X7",
  "ER_IHC" = "X8",
  "AGE_AT_DIAGNOSIS" = "X9",
  "OS_MONTHS" = "time",
  "OS_STATUS" = "status"
)

# Mapping colnames
names(mb)[names(mb) %in% names(var_map)] <- var_map[names(mb)[names(mb) %in% names(var_map)]]

# Looking at the time
summary(mb$time)
# Order according to time and status
mb[order(mb$time, -mb$status),]

```

Next, we load helper functions used throughout our analysis.


```{r load functions}
source("./CindexHelperFunctions.R")
```

Finally, we load the 5-fold cross-validation results from the previous analysis,
which contains the stacked predictions and survival curves for the METABRIC dataset.

```{r Load crossvalidation results}
stacked_predictions <- readRDS("./Results/5foldCV_MetabricStackedPredictions.rds")
survival_curves     <- readRDS("./Results/5foldCV_MetabricSurvivalCurves.rds")
```


```{r Plot survival curves}
# Plot 
plot_survival_curves(survival_curves[[1]]$DeepHit, title = "DeepHit Survival Curves", seed=123)
plot_survival_curves(survival_curves[[1]]$DeepSurv, title = "DeepSurv Survival Curves", seed=123)
plot_survival_curves(survival_curves[[1]]$CoxPH, title = "Cox PH Survival Curves", seed=123)
plot_survival_curves(survival_curves[[1]]$Coxtime, title = "Cox Time Survival Curves", seed=123)
plot_survival_curves(survival_curves[[1]]$RSF, title = "RSF Survival Curves", seed=123)
```

# Ties in times

The number of ties will be increased by rounding the `test_time` variable in the 
stacked predictions. This corresponds to rounding the observed survival times 
(censored or not) in the test set. Un-rounded values are used within the training
set. We will use the results from the 5 fold CV, and generate bootstrap samples 
to estimate the C-index confidence intervals. We also estimate the C-index point 
estimates. 

## Rounding and descriptive statistics

First, we summarise the number of tied times in the raw METABRIC dataset. 

```{r Number unique of event times No rounding}
# total possible pairs in Metabric
n_total_pairs <- ((nrow(stacked_predictions))*(nrow(stacked_predictions)-1)) / 2

cat("New number of unique times: ", length(unique(stacked_predictions$test_time)), "\n")

table_times <- table(stacked_predictions$test_time)
ties_times <- table_times[table_times > 1]

num_tied_pairs <- sum(choose(ties_times, 2))

cat("Number of pairs that have tied times: ", num_tied_pairs, "\n")
cat("% of tied pairs out of total possible pairs ", num_tied_pairs/n_total_pairs *100, "\n")
```

Next, we do the same but after rounding the `test_time` variable to the nearest
integer.

```{r Number unique of event times after Rounding(T,0)}
stacked_predictions_T2 <- stacked_predictions
stacked_predictions_T2$test_time <- round(stacked_predictions_T2$test_time)

cat("New number of unique times: ", length(unique(stacked_predictions_T2$test_time)), "\n")

table_times <- table(stacked_predictions_T2$test_time)
ties_times <- table_times[table_times > 1]

num_tied_pairs <- sum(choose(ties_times, 2))

cat("Number of pairs that have tied times: ", num_tied_pairs, "\n")
cat("% of tied pairs out of total possible pairs ", num_tied_pairs/n_total_pairs *100, "\n")
```

## Boostrap samples

For reproducibility across different models, we first generate bootstrap samples
which will be shared across all models and with or without data rounding. 


```{r Create bootstrap samples, eval=FALSE}
set.seed(123)

# Number of bootstraps
n_bootstraps <- 100

# Size of bootstrap sample
size_sample <- 1000

# re-sample by patient id
resample_indices <- replicate(n_bootstraps, 
                              sample(stacked_predictions$patients_ids, 
                                     size = size_sample, replace = TRUE), 
                              simplify = FALSE)
```




```{r Commented out}
# Bin test_time into 3-month intervals
# stacked_predictions_B <- stacked_predictions
# Get bin midpoints
# bin_midpoints <- seq(0, max(stacked_predictions_B$test_time, na.rm = TRUE) + 3, by = 3) + 1.5
# bin_midpoints <- bin_midpoints[-length(bin_midpoints)]  # remove last as itâ€™s beyond max
# stacked_predictions_B$test_time <- cut(stacked_predictions_B$test_time, 
#                       breaks = seq(0, max(stacked_predictions_B$test_time, na.rm = TRUE) + 3, by = 3), 
#                       right = FALSE, include.lowest = TRUE)
# 
# cat("New number of unique times: ", length(unique(stacked_predictions_B$test_time)), "\n")
# 
# table_times <- table(stacked_predictions_B$test_time)
# ties_times <- table_times[table_times > 1]
# 
# num_tied_pairs <- sum(choose(ties_times, 2))
# cat("Number of pairs that have tied times: ", num_tied_pairs, "\n")

# Map levels to midpoints
# stacked_predictions_B$test_time<- bin_midpoints[as.numeric(stacked_predictions_B$test_time)]
# 
# 
# cat("% of tied pairs out of total possible pairs ", num_tied_pairs/n_total_pairs *100, "\n")

```


## Extract model predictions

We consider RMST and the survival probabilities themselves (needed for `pycox`)

Based on the resample indices for the bootstrap, we generate subsets of the data, 
that contain the right input type (survival probabilities or RMST), for the right models. 


```{r Generate subsets from bootstrap indexes. No rounding}

subset_expm <- list()
subset_surv <- list()
subset_rmst <- list()

for (r in seq_along(resample_indices)) {
  
  subset_surv[[r]] <- get_model_preds2(stacked_predictions = stacked_predictions, 
                model_names = "all",
                input_type = "Distribution",
                bootstrap_patient_ids = resample_indices[[r]])
  subset_rmst[[r]] <- get_model_preds2(stacked_predictions = stacked_predictions, 
                  model_names = "all",
                  input_type = "RMST",
                  bootstrap_patient_ids = resample_indices[[r]])
  
}
```


```{r Generate subsets from bootstrap indexes. Rounding(T, 0)}
subset_expm_T2 <- list()
subset_surv_T2 <- list()
subset_rmst_T2 <- list()
for (r in seq_along(resample_indices)) {

  subset_surv_T2[[r]] <- get_model_preds2(stacked_predictions = stacked_predictions_T2, 
                model_names = "all",
                input_type = "Distribution",
                bootstrap_patient_ids = resample_indices[[r]])
  subset_rmst_T2[[r]] <- get_model_preds2(stacked_predictions = stacked_predictions_T2, 
                model_names = "all",
                input_type = "RMST",
                bootstrap_patient_ids = resample_indices[[r]])
  
  
}
```

## C-index estimation

The implementations are chosen for their ability to turn on and off the inclusion of ties in times. 
Therefore only `pec` is tested here for $C_\tau$, and `pycox` is tested for $C_{td}$. 
However, none of the implementations we have gathered in this study estimating $C$ allow for inclusion/exclusion of ties based on user-defined parameters. 


```{r Estimation C-index No rounding}
# Get the right columns
select_rmst <- grep("RMST\\.",colnames(subset_rmst[[1]]), value = TRUE)
# Generate empty lists to store results
results_rmst_pe_incl_ties <- list() # point estimates including ties
results_rmst_pe_excl_ties <- list() # point estimates excluding ties
results_rmst_bo_excl_ties <- list() # bootstrap excluding ties
results_rmst_bo_incl_ties <- list() # bootstrap including ties

# Run the Ctau
for (rmst in select_rmst) {
   cat("Calculating bootstrap for RSMT for Model = ", rmst, "\n")
   # Run the inclusion of ties
   # Bootstrap
   results_rmst_bo_incl_ties[[rmst]] <- bootstrap.metric.parallel(metrics.wrapper2,
                                  dataset=list(
                                     predicted = rmst,
                                     censoring = "test_status",
                                     time = "test_time"),
                                  implementation = list("pec::cindex"),
                                  eval.times = 120, 
                                  sampled_data = subset_rmst, 
                                  additional = list(
                                    pec_incl_ties_pred = TRUE,
                                    pec_incl_ties_times = TRUE,
                                    pec_incl_both_tied = TRUE
                                  ))
   # Point estimate
   results_rmst_pe_incl_ties[[rmst]] <- metrics.wrapper2(predicted = stacked_predictions[[rmst]],
                                                        censoring = stacked_predictions$test_status,
                                                        time = stacked_predictions$test_time,
                                                        implementation = list("pec::cindex"),
                                                        eval.times = 120,
                                                        pec_incl_ties_pred = TRUE,
                                                        pec_incl_ties_times = TRUE,
                                                        pec_incl_both_tied = TRUE
                                                        )
   # Run the exclusion of ties
   # Bootstrap
   results_rmst_bo_excl_ties[[rmst]] <- bootstrap.metric.parallel(metrics.wrapper2,
                                  dataset=list(
                                     predicted = rmst,
                                     censoring = "test_status",
                                     time = "test_time"),
                                  implementation = list("pec::cindex"),
                                  eval.times = 120, 
                                  sampled_data = subset_rmst, 
                                  additional = list(
                                    pec_incl_ties_pred = TRUE,
                                    pec_incl_ties_times = FALSE,
                                    pec_incl_both_tied = FALSE
                                    
                                  ))
   # Point estimate
   results_rmst_pe_excl_ties[[rmst]] <- metrics.wrapper2(predicted = stacked_predictions[[rmst]],
                                                        censoring = stacked_predictions$test_status,
                                                        time = stacked_predictions$test_time,
                                                        implementation = list("pec::cindex"),
                                                        eval.times = 120,
                                                        pec_incl_ties_pred = TRUE,
                                                        pec_incl_ties_times = FALSE,
                                                        pec_incl_both_tied = FALSE)
}


# Run the Ctd
# Get the right columns
model_names <- unique(sub("\\..*", "", grep("^[A-Za-z]+\\.\\d+$",
                                            colnames(subset_surv[[1]]), value = TRUE)))
# Generate empty lists
results_surv_bo <- list()
results_surv_pe <- list()
for (model in model_names) {
  cat("Calculating bootstrap for Distribution for Model = ", model, "\n")
  # Boostrap
  results_surv_bo[[model]] <-  bootstrap.metric(metrics.wrapper,
                                  dataset=list(
                                     predicted = model,
                                     censoring = "test_status",
                                     time = "test_time"),
                                  implementation = list("pycox.Adj.Ant", "pycox.Ant"),
                                  sampled_data = subset_surv)
  
  # Generate matrix for the point estimate calculation
  surv_mat = stacked_predictions[, grep(paste0("^", model), names(stacked_predictions), 
                                        value = TRUE), drop = FALSE]
  colnames(surv_mat) <- as.numeric(sub(".*\\.", "", colnames(surv_mat)))
  # Point estimate
  results_surv_pe[[model]] <- metrics.wrapper(surv_matrix = surv_mat, 
                                                    censoring = stacked_predictions$test_status, 
                                                    time = stacked_predictions$test_time, 
                                                    implementation = list("pycox.Ant",
                                                                          "pycox.Adj.Ant"))

}

```

```{r Estimation of C-index Rounding(T,0)}
# Get the right column
select_rmst_T2 <- grep("RMST\\.",colnames(subset_rmst_T2[[1]]), value = TRUE)
# Generate the empty lists
results_rmst_pe_incl_ties_T2 <- list() 
results_rmst_pe_excl_ties_T2 <- list() 
results_rmst_bo_excl_ties_T2 <- list()
results_rmst_bo_incl_ties_T2 <- list()
# Run the Ctau
for (rmst in select_rmst_T2) {
   cat("Calculating bootstrap for RSMT for Model = ", rmst, "\n")
    # Run the inclusion of ties
   # Bootstrap
   results_rmst_bo_incl_ties_T2[[rmst]] <- bootstrap.metric.parallel(metrics.wrapper2,
                                  dataset=list(
                                     predicted = rmst,
                                     censoring = "test_status",
                                     time = "test_time"),
                                  implementation = list("pec::cindex"),
                                  eval.times = 120, 
                                  sampled_data = subset_rmst_T2, 
                                  additional = list(
                                    pec_incl_ties_pred = TRUE,
                                    pec_incl_ties_times = TRUE,
                                    pec_incl_both_tied = TRUE
                                    
                                  ))
   # Point estimate
   results_rmst_pe_incl_ties_T2[[rmst]] <- metrics.wrapper2(predicted = stacked_predictions_T2[[rmst]],
                                                        censoring = stacked_predictions_T2$test_status,
                                                        time = stacked_predictions_T2$test_time,
                                                        implementation = list("pec::cindex"),
                                                        eval.times = 120,
                                                        pec_incl_ties_pred = TRUE,
                                                        pec_incl_ties_times = TRUE,
                                                        pec_incl_both_tied = TRUE
                                                        )
   # Run the exclusion of ties
   # Bootstrap
   results_rmst_bo_excl_ties_T2[[rmst]] <- bootstrap.metric.parallel(metrics.wrapper2,
                                  dataset=list(
                                     predicted = rmst,
                                     censoring = "test_status",
                                     time = "test_time"),
                                  implementation = list("pec::cindex"),
                                  eval.times = 120, 
                                  sampled_data = subset_rmst_T2, 
                                  additional = list(
                                    pec_incl_ties_pred = TRUE,
                                    pec_incl_ties_times = FALSE,
                                    pec_incl_both_tied = FALSE
                                    
                                  ))
   # Point estimate
   results_rmst_pe_excl_ties_T2[[rmst]] <- metrics.wrapper2(predicted = stacked_predictions_T2[[rmst]],
                                                        censoring = stacked_predictions_T2$test_status,
                                                        time = stacked_predictions_T2$test_time,
                                                        implementation = list("pec::cindex"),
                                                        eval.times = 120,
                                                        pec_incl_ties_pred = TRUE,
                                                        pec_incl_ties_times = FALSE,
                                                        pec_incl_both_tied = FALSE)
   
   

}

# Extract the right columns
model_names <- unique(sub("\\..*", "", grep("^[A-Za-z]+\\.\\d+$",
                                            colnames(subset_surv_T2[[1]]), value = TRUE)))
results_surv_bo_T2 <- list()
results_surv_pe_T2 <- list()
# Run the Ctd
for (model in model_names) {
  cat("Calculating bootstrap for Distribution for Model = ", model, "\n")
  # Bootstrap
  results_surv_bo_T2[[model]] <-  bootstrap.metric(metrics.wrapper,
                                  dataset=list(
                                     predicted = model,
                                     censoring = "test_status",
                                     time = "test_time"),
                                  implementation = list("pycox.Adj.Ant", "pycox.Ant"),
                                  sampled_data = subset_surv_T2)
  # Generate matrix 
  surv_mat = stacked_predictions_T2[, grep(paste0("^", model), names(stacked_predictions_T2), 
                                        value = TRUE), drop = FALSE]
  colnames(surv_mat) <- as.numeric(sub(".*\\.", "", colnames(surv_mat)))
  # Point estimate
  results_surv_pe_T2[[model]] <- metrics.wrapper(surv_matrix = surv_mat, 
                                                    censoring = stacked_predictions_T2$test_status, 
                                                    time = stacked_predictions_T2$test_time, 
                                                    implementation = list("pycox.Ant",
                                                                          "pycox.Adj.Ant"))

}

```

## Results

Here, we extract the information used to generate our plots:


```{r Extract the information from list to plot}
# Extract inf for plotting
rmst_pec_excl_ties  <- make_rmst_plot_entries(results_rmst_bo_excl_ties,  
                                              results_rmst_pe_excl_ties)
rmst_pec_incl_ties  <- make_rmst_plot_entries(results_rmst_bo_incl_ties,  
                                              results_rmst_pe_incl_ties)

rmst_pec_excl_ties_T2  <- make_rmst_plot_entries(results_rmst_bo_excl_ties_T2,
                                                 results_rmst_pe_excl_ties_T2)
rmst_pec_incl_ties_T2  <- make_rmst_plot_entries(results_rmst_bo_incl_ties_T2,  
                                                 results_rmst_pe_incl_ties_T2)

rmst_pec_excl_ties_TT  <- make_rmst_plot_entries(results_rmst_bo_excl_ties_TT,
                                                 results_rmst_pe_excl_ties_TT)
rmst_pec_incl_ties_TT  <- make_rmst_plot_entries(results_rmst_bo_incl_ties_TT,  
                                                 results_rmst_pe_incl_ties_TT)


surv_df_plot    <- make_surv_plot_entries(results_surv_bo, results_surv_pe)
surv_df_plot_TT <- make_surv_plot_entries(results_surv_bo_TT, results_surv_pe_TT)
surv_df_plot_T2 <- make_surv_plot_entries(results_surv_bo_T2, results_surv_pe_T2)
```

```{r Format it to plot}
# Add notation
surv_df_plot$Notation            <- "C_td"
rmst_pec_excl_ties$Notation      <- "C_tau_10"
rmst_pec_incl_ties$Notation      <- "C_tau_10"

surv_df_plot_T2$Notation         <- "C_td"  
rmst_pec_excl_ties_T2$Notation   <- "C_tau_10"
rmst_pec_incl_ties_T2$Notation   <- "C_tau_10"

## Add the tie not ties
surv_df_plot$Incl.Ties.Times    <- ifelse(surv_df_plot$Metric == "pycox.Adj.Ant", 
                                          "pycox.Adj.Ant", "pycox.Ant*")

surv_df_plot_T2$Incl.Ties.Times <- ifelse(surv_df_plot_T2$Metric == "pycox.Adj.Ant", 
                                          "pycox.Adj.Ant", "pycox.Ant*")

rmst_pec_incl_ties$Incl.Ties.Times     <- rmst_pec_incl_ties$Metric
rmst_pec_incl_ties_T2$Incl.Ties.Times  <- rmst_pec_incl_ties_T2$Metric

rmst_pec_excl_ties$Incl.Ties.Times     <- paste0(rmst_pec_excl_ties$Metric, "*")
rmst_pec_excl_ties_T2$Incl.Ties.Times  <- paste0(rmst_pec_excl_ties_T2$Metric, "*")


# Adding wounding
surv_df_plot$Rounding          <- "No Rounding"
rmst_pec_excl_ties$Rounding      <- "No Rounding"
rmst_pec_incl_ties$Rounding     <- "No Rounding"

surv_df_plot_T2$Rounding       <- "Round(T,0)"  
rmst_pec_excl_ties_T2$Rounding   <- "Round(T,0)"
rmst_pec_incl_ties_T2$Rounding  <- "Round(T,0)"

# Bind by row
df_plot <- bind_rows(surv_df_plot, rmst_pec_excl_ties, rmst_pec_incl_ties, 
                     surv_df_plot_T2, rmst_pec_excl_ties_T2, rmst_pec_incl_ties_T2)

```


```{r Plot}
# Plot
df_plot$Notation <- factor(df_plot$Notation,
  levels = c("C_tau_10", "C_td"),
  labels = c(
    "tilde(C)[tau]~(RMST~tau==10~years)",
    "tilde(C)[td]~(Survival~Distribution)"
  )
)

df_plot$Rounding <- factor(df_plot$Rounding)
df_plot$Model[df_plot$Model == "CoxPH"] <- "CPH"
df_plot$Model <- factor(df_plot$Model, levels = c("RSF", "CoxTime", 
                                                   "DeepSurv", "CPH", "DeepHit"))

metric_levels <- levels(df_plot$Incl.Ties.Times)
n_metrics <- length(metric_levels)


### Version with color
 ggplot(df_plot, aes(x = Incl.Ties.Times, y = cindex, color = Model)) +
  geom_pointrange(aes(ymin = lower, ymax = upper),
                  position = position_dodge(width = 0.4), size = 0.5) +
  facet_wrap(~ Notation + Rounding , nrow = 2, scales = "free_x", labeller = label_value)+
  # geom_vline(xintercept = separator_positions, 
  #             linetype = "dashed", color = "grey70") +
  ylim(0.5, 0.75) +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "gray") +
  labs(title = "",
       y = "C-index", x = NULL) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom",
  panel.grid.major.x = element_blank(),
  panel.grid.minor.x = element_blank())
 
```

```{r Create table}

surv_df_plot$Incl.Ties.Times    <- ifelse(surv_df_plot$Metric == "pycox.Adj.Ant", 
                                          TRUE, FALSE)
surv_df_plot_T2$Incl.Ties.Times <- ifelse(surv_df_plot_T2$Metric == "pycox.Adj.Ant", 
                                          TRUE, FALSE)

rmst_pec_incl_ties$Incl.Ties.Times     <- TRUE
rmst_pec_incl_ties_T2$Incl.Ties.Times  <- TRUE

rmst_pec_excl_ties$Incl.Ties.Times     <- FALSE
rmst_pec_excl_ties_T2$Incl.Ties.Times  <- FALSE


df_plot <- bind_rows(surv_df_plot, rmst_pec_excl_ties, rmst_pec_incl_ties, 
                     surv_df_plot_T2, rmst_pec_excl_ties_T2, rmst_pec_incl_ties_T2)

# Filter rows
subset_latex <- df_plot

# Create a C-index (95% CI) column
subset_latex$CIndex <- sprintf("%.4f [%.4f, %.4f]",
                                  subset_latex$cindex,
                                  subset_latex$lower,
                                  subset_latex$upper)

# Select relevant columns
subset_latex <- subset_latex[, c("Metric","Model", "Notation", "Rounding", "Incl.Ties.Times", "CIndex")]

subset_latex <- subset_latex[order(subset_latex$Notation,
                                   subset_latex$Rounding,
                                   subset_latex$Incl.Ties.Times), ]

 as_latex <- subset_latex %>%
   kable(format = "latex", booktabs = TRUE)
```


# Ties in predictions

To study the ties in prediction we restart the global environment variables. 

We would create three different models based on increasing discretization of 
the age as covariates. After we would estimate the C-index with those 
implementations where we can change the inclusion of ties in predictions based 
on user-defined parameters. Those are pysurvival and Hmisc for $C$, pec for 
$C_\tau$ and pycox for $C_\{td}$

Here, we restart the environment and load the required libraries. 

```{r Restart}
rm(list = ls())
```

```{r Load libraries, include=FALSE}
# Survival metrics
library(reticulate)
library(arrow)
library(caret)
library(riskRegression)
library(prodlim)
library(pec)
library(survival)
library(rhdf5)
library(randomForestSRC)
#library(survAUC)
library(Hmisc)
library(dplyr)
# Plotting
library(gridExtra)
# Parallelization
library(doFuture)
library(future)
library(progressr)
library(foreach)
library(MASS)
library(flexsurv)
library(furrr)
library(pysurvivalR)
library(survivalmodels)
library(tidyr)
```

We also re-load the data. 

```{r Load data}
# Load data downloaded from the cBioPortal 
mb <- read.table("./Datasets/metabric_preprocess_multiverse.csv", 
                 sep = "," , header = TRUE)

# Keep the id as index
rownames(mb) <- mb$PATIENT_ID

# Remove the id column
mb <- mb[,2:12]

# Mapping
var_map <- c(
  "MKI67" = "X1",
  "EGFR" = "X2",
  "ERBB2" = "X3",
  "PGR" = "X4",
  "HORMONE_THERAPY" = "X5",
  "RADIO_THERAPY" = "X6",
  "CHEMOTHERAPY" = "X7",
  "ER_IHC" = "X8",
  "AGE_AT_DIAGNOSIS" = "X9",
  "OS_MONTHS" = "time",
  "OS_STATUS" = "status"
)

# Mapping colnames
names(mb)[names(mb) %in% names(var_map)] <- var_map[names(mb)[names(mb) %in% names(var_map)]]

# Looking at the time
summary(mb$time)
# Order according to time and status
mb[order(mb$time, -mb$status),]
```
Next, we load the helper functions used throughout our analysis.

```{r Load functions}
source("./CindexHelperFunctions.R")
```

## Age rounding

Here, we apply to different rounding strategies to age. First, we round the 
age to the nearest integer, and then we create 5-year bins.


```{r Number of unique age values}
length(unique(mb$X9))
```

```{r Create age discretizations}
mb$X9_round <- round(mb$X9)

range_start <- floor(min(mb$X9_round, na.rm = TRUE)) - 1
range_end <- ceiling(max(mb$X9_round, na.rm = TRUE)) + 1

mb$X9_bin <- cut(
  mb$X9_round,
  breaks = seq(range_start, range_end, by = 5),
  right = FALSE,
  include.lowest = TRUE
)
breaks <- seq(range_start, range_end, by = 5)

midpoints <- head(breaks, -1) + 2.5

mb$X9_bin <- midpoints[as.integer(mb$X9_bin)]
```

## Model fitting

We will fit Cox PH models using age as the only covariate. Different models will
be fitted using the raw values of age, as well as the two rounded age values 
that were created in the previous section. 

```{r 5foldCV, eval=FALSE}
## Reproducibility
reset_torch_seed <- function(seed = 123) {
  reticulate::py_run_string(sprintf("
import torch
import numpy as np
import random
torch.manual_seed(%d)
np.random.seed(%d)
random.seed(%d)
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False
", seed, seed, seed))
}

set.seed(123)
survivalmodels::set_seed(seed_R=123, seed_np = 123, seed_torch = 123) 

### Crossval
# Number of folds
K <- 5 
n <- nrow(mb)  

# Interesting times for comparison
#ts <- sort(unique(round(mb$time)))
all_predictions <- list()

# List of numeric column for standarization
numeric_cols <- c("X1", "X2", "X3", "X4", "X9")

# Create empty list for survival curves
survival_curves <- vector("list", K)

# Shuffle indices and create folds
folds <- createFolds(mb$status, k = K, list = TRUE) # return test sets

# Interesting intervals for prediction
mb_t_max <- round(max(mb$time))
ts_scaled <- seq(0, mb_t_max, 1)

for (k in 1:K) {

  # Define test and training indices
  mb_test_idx  <- folds[[k]]
  mb_train_idx <- setdiff(seq_len(nrow(mb)), mb_test_idx)
  
  # Subset the dataset
  mb_train <- mb[mb_train_idx, ]
  mb_test  <- mb[mb_test_idx, ]
  
  t_train_max <- max(mb_train$time)
  
  # Scale continuous 
  means <- sapply(mb_train[, numeric_cols], mean)
  sds   <- sapply(mb_train[, numeric_cols], sd)

  mb_train[, numeric_cols] <- scale(mb_train[, numeric_cols],
                                   center = means, scale = sds)
  mb_test[, numeric_cols]  <- scale(mb_test[, numeric_cols],
                                   center = means, scale = sds)

  # Fit models
  #cat("Dataset:", i, ".", j, '\n')
  cat("Fold:", k, '\n')
  cat("tmax:", t_train_max, "\n")
  cat('Train set dimensions:', dim(mb_train), '\n')
  cat('Train set event:', mean(mb_train$status == 1)*100, '\n')
  cat('Train set censoring:', mean(mb_train$status == 0)*100, '\n')
  cat('Test set dimensions:', dim(mb_test), '\n')
  cat('Test set event:', mean(mb_test$status == 1)*100, '\n')
  cat('Test set censoring:', mean(mb_test$status == 0)*100, '\n')
  cat('\n')
  
  predictors <- c("X9", "X9_round", "X9_bin")

  # Create a named list to store results
  cox_surv_list <- list()
  
  for (var in predictors) {
    
    form <- as.formula(paste("Surv(time, status) ~", var))
    
    cox_ph <- coxph(formula = form, data = mb_train)

    sf <- survfit(cox_ph, newdata = mb_test)

    surv_cox <- t(sf$surv)
    time_grid <- sf$time
    
    # Interpolate to ts_scaled
    surv_cox_int <- apply(surv_cox, 1, function(s) {
      approx(x = time_grid, y = s, xout = ts_scaled, rule = 2)$y
    })
    
    surv_cox_int <- t(surv_cox_int)
    rownames(surv_cox_int) <- rownames(mb_test)
    colnames(surv_cox_int) <- ts_scaled
    
    # Store in the list with the predictor name
    cox_surv_list[[var]] <- surv_cox_int
    
  }
  # Gather the survival survs too
  survival_curves[[k]] <- list(patients_ids = rownames(mb_test),
                               test_time = mb_test$time,
                               test_status = mb_test$status,
                               CoxPH = as.data.frame(cox_surv_list[["X9"]]),
                               CoxPH_round = as.data.frame(cox_surv_list[["X9_round"]]),
                               CoxPH_bin = as.data.frame(cox_surv_list[["X9_bin"]]))
  fold_results <- data.frame(cv_fold = k,
                             patients_ids = rownames(mb_test), 
                             test_time = mb_test$time,
                             test_status = mb_test$status,
                             CoxPH = as.data.frame(cox_surv_list[["X9"]]),
                             CoxPH_round = as.data.frame(cox_surv_list[["X9_round"]]),
                             CoxPH_bin = as.data.frame(cox_surv_list[["X9_bin"]]))
    

  # Append fold results to the list
 all_predictions[[paste("Fold", k)]] <- fold_results

}

folds_stacked_predictions <- do.call(rbind, all_predictions)


model_names <- c("CoxPH", "CoxPH_round", "CoxPH_bin")

df <- folds_stacked_predictions[, 1:4]

for (model in model_names) {
  res <- compute_measures(folds_stacked_predictions, model)
  df[[paste0("ExpMort.", model)]] <- res$exp_mort
  df[[paste0("RMST.", model)]] <- res$rmst
  
  surv_mat <- as.data.frame(res$surv_mat)
  
  df <- cbind(df, surv_mat)
}

stacked_predictions <- df

```



```{r Characteristics of predictions with No rounding}
cat("Number of patients: ", nrow(stacked_predictions), "\n")
cat("Number of unique predictions: ", length(unique(stacked_predictions$ExpMort.CoxPH)), "\n")

# Number of tied predictions ExpMort
table_pred <- table(stacked_predictions$ExpMort.CoxPH)
ties_pred <- table_pred[table_pred  > 1]
num_tied_pairs <- sum(choose(table_pred , 2))
n_tied_pairs <- sum((table_pred * (table_pred  - 1)) / 2)
cat("Number of pairs that have tied preds Cox PH (exp mort): ", num_tied_pairs, "\n")

# Number of tied predictions RMST
table_pred <- table(stacked_predictions$RMST.CoxPH)
ties_pred <- table_pred[table_pred  > 1]

num_tied_pairs <- sum(choose(table_pred , 2))
n_tied_pairs <- sum((table_pred * (table_pred  - 1)) / 2)
cat("Number of pairs that have tied preds Cox PH (rmst): ", num_tied_pairs, "\n")

n_total_pairs <- ((nrow(stacked_predictions))*(nrow(stacked_predictions)-1)) / 2

cat("% of tied pairs out of total possible pairs ", num_tied_pairs/n_total_pairs *100, "\n")

```


```{r Characteristics of predictions with Rounding(age, 0)}
cat("Number of patients: ", nrow(stacked_predictions), "\n")
cat("Number of unique predictions: ", length(unique(stacked_predictions$ExpMort.CoxPH_round)), "\n")

# Number of tied predictions ExpMort
table_pred <- table(stacked_predictions$ExpMort.CoxPH_round)
ties_pred <- table_pred[table_pred  > 1]
num_tied_pairs <- sum(choose(table_pred , 2))
n_tied_pairs <- sum((table_pred * (table_pred  - 1)) / 2)
cat("Number of pairs that have tied preds Cox PH (exp mort): ", num_tied_pairs, "\n")

# Number of tied predictions RMST
table_pred <- table(stacked_predictions$RMST.CoxPH_round)
ties_pred <- table_pred[table_pred  > 1]

num_tied_pairs <- sum(choose(table_pred , 2))
n_tied_pairs <- sum((table_pred * (table_pred  - 1)) / 2)
cat("Number of pairs that have tied preds Cox PH (rmst): ", num_tied_pairs, "\n")

n_total_pairs <- ((nrow(stacked_predictions))*(nrow(stacked_predictions)-1)) / 2

cat("% of tied pairs out of total possible pairs ", num_tied_pairs/n_total_pairs *100, "\n")

```


```{r Characteristics of predictions with Binning(age, 5)}
cat("Number of patients: ", nrow(stacked_predictions), "\n")
cat("Number of unique predictions: ", length(unique(stacked_predictions$ExpMort.CoxPH_bin)), "\n")

# Number of tied predictions ExpMort
table_pred <- table(stacked_predictions$ExpMort.CoxPH_bin)
ties_pred <- table_pred[table_pred  > 1]
num_tied_pairs <- sum(choose(table_pred , 2))
n_tied_pairs <- sum((table_pred * (table_pred  - 1)) / 2)
cat("Number of pairs that have tied preds Cox PH (exp mort): ", num_tied_pairs, "\n")

# Number of tied predictions RMST
table_pred <- table(stacked_predictions$RMST.CoxPH_bin)
ties_pred <- table_pred[table_pred  > 1]

num_tied_pairs <- sum(choose(table_pred , 2))
n_tied_pairs <- sum((table_pred * (table_pred  - 1)) / 2)
cat("Number of pairs that have tied preds Cox PH (rmst): ", num_tied_pairs, "\n")

n_total_pairs <- ((nrow(stacked_predictions))*(nrow(stacked_predictions)-1)) / 2

cat("% of tied pairs out of total possible pairs ", num_tied_pairs/n_total_pairs *100, "\n")

```

```{r Bootstrap sample generation, eval=FALSE}

set.seed(123)
# Number of bootstrapps
n_bootstraps <- 100
# Size of boostrap sample
size_sample <- 1000

# re sample by patient id
resample_indices <- replicate(n_bootstraps, 
                              sample(stacked_predictions$patients_ids, 
                                     size = size_sample, replace = TRUE), 
                              simplify = FALSE)
```


```{r Extract datasets from bootstrap sample indices}
subset_rmst <- list()
subset_surv <- list()

for (r in seq_along(resample_indices)) {

  subset_rmst[[r]] <- get_model_preds2(stacked_predictions = stacked_predictions, 
                 model_names = "all",
                 input_type = "RMST",
                 bootstrap_patient_ids = resample_indices[[r]])
  subset_surv[[r]] <- get_model_preds2(stacked_predictions = stacked_predictions, 
                model_names = c("CoxPH", "CoxPH_round", "CoxPH_bin"),
                input_type = "Distribution",
                bootstrap_patient_ids = resample_indices[[r]])
}
```



```{r Estimate C-index}
preds <- c("RMST.CoxPH", "RMST.CoxPH_round", "RMST.CoxPH_bin")
results_rmst_bo_incl_ties <- list() # boostrap results
results_rmst_pe_incl_ties <- list() # point estimate
results_rmst_bo_excl_ties <- list() # boostrap results
results_rmst_pe_excl_ties <- list() # point estimate
for (rmst in preds) {
   cat("Calculating bootstrap for RMST for Model = ", rmst, "\n")
  # Bootstrap
   results_rmst_bo_excl_ties[[rmst]] <- bootstrap.metric.parallel(metrics.wrapper2,
                                  dataset=list(
                                     predicted = rmst,
                                     censoring = "test_status",
                                     time = "test_time"),
                                  implementation = list("Hmisc::rcorr.cens",
                                                        "pysurvival",
                                                        "pec::cindex"),
                                  eval.times = 120, 
                                  sampled_data = subset_rmst, 
                                  additional = list(
                                    pec_incl_ties_preds = FALSE, # pec TRUE default 
                                    pec_incl_ties_times = TRUE, # pec TRUE default 
                                    pec_incl_both_tied = FALSE, # pec TRUE default 
                                    hmisc_excl_ties_preds = TRUE, # default is False 
                                    pysurvival_incl_ties_preds = FALSE # default is TRUE
                                  ))
   
    results_rmst_bo_incl_ties[[rmst]] <- bootstrap.metric.parallel(metrics.wrapper2,
                                  dataset=list(
                                     predicted = rmst,
                                     censoring = "test_status",
                                     time = "test_time"),
                                  implementation = list("Hmisc::rcorr.cens",
                                                        "pysurvival",
                                                        "pec::cindex"),
                                  eval.times = 120, #C
                                  sampled_data = subset_rmst, 
                                  additional = list(
                                    pec_incl_ties_preds = TRUE, # pec TRUE default 
                                    pec_incl_ties_times = TRUE, # pec TRUE default 
                                    pec_incl_both_tied = TRUE, # pec TRUE default 
                                    hmisc_excl_ties_preds = FALSE, # default is False 
                                    pysurvival_incl_ties_preds = TRUE # default is TRUE
                                  ))
    # Point estimate
   results_rmst_pe_incl_ties[[rmst]] <- metrics.wrapper2(predicted = stacked_predictions[[rmst]],
                                                    censoring = stacked_predictions$test_status,
                                                    time = stacked_predictions$test_time,
                                                    implementation = list("Hmisc::rcorr.cens",
                                                                          "pysurvival",
                                                                          "pec::cindex"),
                                                    eval.times =  120, 
                                                    pec_incl_ties_preds = TRUE, # pec TRUE default 
                                                    pec_incl_ties_times = TRUE, # pec TRUE default 
                                                    pec_incl_both_tied = TRUE, # pec TRUE default 
                                                    hmisc_excl_ties_preds = FALSE, # default is False 
                                                    pysurvival_incl_ties_preds = TRUE # default is TRUE
                                                    )
    results_rmst_pe_excl_ties[[rmst]] <- metrics.wrapper2(predicted = stacked_predictions[[rmst]],
                                                    censoring = stacked_predictions$test_status,
                                                    time = stacked_predictions$test_time,
                                                    implementation = list("Hmisc::rcorr.cens",
                                                                          "pysurvival",
                                                                          "pec::cindex"),
                                                    eval.times =  120, 
                                                    pec_incl_ties_preds = FALSE, # pec TRUE default 
                                                    pec_incl_ties_times = TRUE, # pec TRUE default 
                                                    pec_incl_both_tied = FALSE, # pec TRUE default 
                                                    hmisc_excl_ties_preds = TRUE, # default is False 
                                                    pysurvival_incl_ties_preds = FALSE# default is TRUE
                                                    )
}

model_names <- c("CoxPH", "CoxPH_round", "CoxPH_bin")

results_surv_bo <- list()
results_surv_pe <- list()
for (model in model_names) {
  # Antolinis
  cat("Calculating bootstrap for Distribution for Model = ", model, "\n")
  results_surv_bo[[model]] <-  bootstrap.metric(metrics.wrapper,
                                  dataset=list(
                                     predicted = model,
                                     censoring = "test_status",
                                     time = "test_time"),
                                  implementation = list("pycox.Ant", "pycox.Adj.Ant"),
                                  sampled_data = subset_surv)
  
      
  # Generate matrix
  surv_mat = stacked_predictions[, grep(paste0("^", model, "\\."), names(stacked_predictions), 
                                        value = TRUE), drop = FALSE]
  colnames(surv_mat) <- as.numeric(sub(".*\\.", "", colnames(surv_mat)))
  # Point estimate
  results_surv_pe[[model]] <- metrics.wrapper(surv_matrix = surv_mat, 
                                                    censoring = stacked_predictions$test_status, 
                                                    time = stacked_predictions$test_time, 
                                                    implementation = list("pycox.Ant",
                                                                          "pycox.Adj.Ant"))
}
```


```{r Extract the inforation from list to plot}   
rmst_df_plot_incl_ties <- make_rmst_plot_entries(results_rmst_bo_incl_ties, 
                                                 results_rmst_pe_incl_ties)
rmst_df_plot_excl_ties <- make_rmst_plot_entries(results_rmst_bo_excl_ties,
                                                 results_rmst_pe_excl_ties)

surv_df_plot <- make_surv_plot_entries(results_surv_bo, results_surv_pe)
```


```{r Format and plot 2  fig.width=8, fig.height=9}

# Add notation
surv_df_plot$Notation           <- "C_td"
rmst_df_plot_incl_ties$Notation <- ifelse(rmst_df_plot_incl_ties$Metric == "pec", "C_tau_10", "C")
rmst_df_plot_excl_ties$Notation <- ifelse(rmst_df_plot_excl_ties$Metric == "pec", "C_tau_10", "C")


## Add the tie not ties
surv_df_plot$Incl.Ties.Preds <- ifelse(surv_df_plot$Metric == "pycox.Adj.Ant", 
                                          "pycox.Adj.Ant*", "pycox.Ant")
rmst_df_plot_incl_ties$Incl.Ties.Preds <- paste0(rmst_df_plot_incl_ties$Metric, "*")
rmst_df_plot_excl_ties$Incl.Ties.Preds <- rmst_df_plot_excl_ties$Metric

# Bind by row
df_plot <- bind_rows(surv_df_plot, rmst_df_plot_incl_ties, rmst_df_plot_excl_ties)

df_plot$Rounding <- factor(df_plot$Model, levels = c("CoxPH", "CoxPH_round", "CoxPH_bin"),
                        labels = c("No~Rounding", "Rounding(age,~0)", "Binned(age,~5)"))

# Define manual order for display
ordered_levels <- c(
  "pycox.Ant", "pycox.Adj.Ant*",
  "pec", "pec*",
  "Hmisc", "Hmisc*",
  "pysurvival", "pysurvival*"
)

# Find remaining levels and append them
all_levels <- unique(df_plot$Incl.Ties.Preds)
remaining_levels <- setdiff(all_levels, ordered_levels)

# Combine to form final order
final_levels <- c(ordered_levels, remaining_levels)

df_plot$Incl.Ties.Preds <- factor(df_plot$Incl.Ties.Preds, levels = final_levels)


ggplot(df_plot, aes(x = Incl.Ties.Preds, y = cindex, color = Notation)) +
  geom_pointrange(aes(ymin = lower, ymax = upper),
                  position = position_dodge(width = 0.6), size = 0.6) +
   facet_wrap(~ Rounding, nrow = 1, scales = "free_x", labeller = label_parsed)+
    scale_color_manual(
    values = c("C" = "#1b9e77", "C_tau_10" = "#d95f02", "C_td" = "#7570b3"),
    labels = c(
      expression(tilde(C)),
      expression(tilde(C)[tau]~(tau==10)),
      expression(tilde(C)[td])
    )
  ) +
  ylim(0.5, 0.7) +
  labs(title = "",
       y = "C-index", x = NULL) +
  
  theme_minimal(base_size = 16.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") 
```

